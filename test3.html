<!DOCTYPE html>

<html>

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>GAME</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://cdn.babylonjs.com/recast.js"></script>
        <script src="https://cdn.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/havok/HavokPhysics_umd.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://cdn.babylonjs.com/earcut.min.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://cdn.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://cdn.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://cdn.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://cdn.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #canvasZone {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
<body>
    <div id="canvasZone"><canvas id="renderCanvas"></canvas></div>
    
    <script>
        var canvas = document.getElementById("renderCanvas");

        var startRenderLoop = function (engine, canvas) {
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        }

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function() { return new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false}); };
        var createScene = function () {
    var scene = new BABYLON.Scene(engine);

    // Lights
    //var light0 = new BABYLON.DirectionalLight("Omni", new BABYLON.Vector3(-2, -5, 2));
    var light1 = new BABYLON.HemisphericLight("Omni", new BABYLON.Vector3(12, -10, -200));
    light1.diffuse = new BABYLON.Color3(0.9,0.8,1);
    light1.intensity = 0.5 ;
    var light2 = new BABYLON.HemisphericLight("Omni", new BABYLON.Vector3(-40, -10, 100));
    light2.diffuse = new BABYLON.Color3(0.9,1,1);
    light2.intensity = 0.5 ;

    // Need a free camera for collisions
    var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, -8, -20));

    //Ground
    var ground = BABYLON.CreatePlane("ground", { size: 50.0 });
    ground.material = new BABYLON.StandardMaterial("groundMat");
    ground.material.diffuseTexture = new BABYLON.Texture("/grass.jpeg");
            ground.material.diffuseTexture.uScale = 20; 
        ground.material.diffuseTexture.vScale = 20; 
    ground.material.diffuseColor = new BABYLON.Color3(0.7, 1.5, 0.7);
     ground.material.backFaceCulling = false;
    ground.position = new BABYLON.Vector3(0, -10, 0);
    ground.rotation = new BABYLON.Vector3(Math.PI / 2, 0, 0);
    
    

    //Simple crate
    // Create the cube
    
    const cube = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 45 , depth : 0.25}, scene);
    cube.position = new BABYLON.Vector3(0,-8,22.5);
    // Apply the texture to the cube
    const cubeMaterial = new BABYLON.StandardMaterial("cubeMaterial", scene);
    cubeMaterial.diffuseTexture = new BABYLON.Texture("/wood1.jpeg", scene);
    cubeMaterial.diffuseTexture.uScale = 1.5; 
    cubeMaterial.backFaceCulling = false;
    cubeMaterial.diffuseTexture.vScale = 1.5; 
    cube.material = cubeMaterial;
    
    const cubeMaterial1 = new BABYLON.StandardMaterial("cubeMaterial", scene);
    cubeMaterial1.diffuseTexture = new BABYLON.Texture("/marble.jpeg", scene);
    cubeMaterial1.diffuseTexture.uScale = 2; 
    cubeMaterial1.backFaceCulling = false;
    cubeMaterial1.diffuseTexture.vScale = 2; 
    
    const cubeMaterial2 = new BABYLON.StandardMaterial("cubeMaterial", scene);
    cubeMaterial2.diffuseTexture = new BABYLON.Texture("/ceiling.jpg", scene);
    cubeMaterial2.diffuseTexture.uScale = 4; 
    cubeMaterial2.backFaceCulling = false;
    cubeMaterial2.diffuseTexture.vScale = 4; 
    
    const cubeMaterial3 = new BABYLON.StandardMaterial("cubeMaterial", scene);
    cubeMaterial3.diffuseTexture = new BABYLON.Texture("/wall.jpg", scene);
    cubeMaterial3.diffuseTexture.uScale = 1; 
    cubeMaterial3.backFaceCulling = false;
    cubeMaterial3.diffuseTexture.vScale = 1; 
    // Enable collision for the cube
    cube.checkCollisions = true;
    
    
    const cube1 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 0.25 , depth : 45}, scene);
    cube1.position = new BABYLON.Vector3(22.5,-8,0);
    cube1.checkCollisions = true ;
    cube1.material = cubeMaterial;
    
    const cube2 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 0.25 , depth : 45}, scene);
    cube2.position = new BABYLON.Vector3(-22.5,-8,0);
    cube2.checkCollisions = true ;
    cube2.material = cubeMaterial;
    
    const cube3 = BABYLON.MeshBuilder.CreateBox("cube", {height: 0.1 , width : 45 , depth : 45}, scene);
    cube3.position = new BABYLON.Vector3(0,-5.95,0);
    cube3.checkCollisions = true ;
    cube3.material = cubeMaterial2;
    
     const cube4 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 10 , depth : 0.25}, scene);
    cube4.position = new BABYLON.Vector3(-17.50,-8,16.5);
    cube4.checkCollisions = true ;
    cube4.material = cubeMaterial3;
    
    const cube5 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 45 , depth : 0.25}, scene);
    cube5.position = new BABYLON.Vector3(0,-8,-22.5);
    cube5.checkCollisions = true ;
    cube5.material = cubeMaterial;
    
    const cube6 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 10 , depth : 0.25}, scene);
    cube6.position = new BABYLON.Vector3(-17.50,-8,10.5);
    cube6.checkCollisions = true ;
    cube6.material = cubeMaterial3;
    
    const cube7 = BABYLON.MeshBuilder.CreateBox("cube", {height: 1 , width : 0.25 , depth : 12.5}, scene);
    cube7.position = new BABYLON.Vector3(-12.5,-6.5,16.5);
    cube7.checkCollisions = true ;
    cube7.material = cubeMaterial;
    
    const cube8 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 15 , depth : 0.25}, scene);
    cube8.position = new BABYLON.Vector3(-17.50,-8,-15.5);
    cube8.checkCollisions = true ;
    cube8.material = cubeMaterial3;
    
    const cube9 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 15 , depth : 0.25}, scene);
    cube9.position = new BABYLON.Vector3(-17.50,-8,-5.5);
    cube9.checkCollisions = true ;
    cube9.material = cubeMaterial3;
    
    const cube10 = BABYLON.MeshBuilder.CreateBox("cube", {height: 1 , width : 0.25 , depth : 17.5}, scene);
    cube10.position = new BABYLON.Vector3(-10,-6.5,-14);
    cube10.checkCollisions = true ;
    cube10.material = cubeMaterial;
    
    const cube11 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 15 , depth : 0.25}, scene);
    cube11.position = new BABYLON.Vector3(2,-8,-15.5);
    cube11.checkCollisions = true ;
    cube11.material = cubeMaterial;
    
    const cube12 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 0.25 , depth : 7.5}, scene);
    cube12.position = new BABYLON.Vector3(9.5,-8,-18.75);
    cube12.checkCollisions = true ;
    cube12.material = cubeMaterial;
    
    const cube13 = BABYLON.MeshBuilder.CreateBox("cube", {height: 4 , width : 0.25 , depth : 38}, scene);
    cube13.position = new BABYLON.Vector3(-5.5,-8,3.5);
    cube13.checkCollisions = true ;
    cube13.material = cubeMaterial;
    
    BABYLON.SceneLoader.ImportMesh("", "/", "old_bed.glb", scene, function (meshes) {
        // Set the position of the imported model
        meshes.forEach(function (mesh) {
            mesh.position = new BABYLON.Vector3(-21, -11,22);
            mesh.scaling = new BABYLON.Vector3(1.5,1.5,1.5);
            mesh.checkCollisions = true ;
        });
    });
    
        BABYLON.SceneLoader.ImportMesh("", "/", "old_bed.glb", scene, function (meshes) {
        // Set the position of the imported model
        meshes.forEach(function (mesh) {
            mesh.position = new BABYLON.Vector3(-21, -11,16);
            mesh.scaling = new BABYLON.Vector3(1.5,1.5,1.5);
            mesh.checkCollisions = true ;
        });
    });
    
    const cube14 = BABYLON.MeshBuilder.CreateBox("cube", {height: 0.1 , width : 45 , depth : 45}, scene);
    cube14.position = new BABYLON.Vector3(0,-10.048,0);
    cube14.checkCollisions = true ;
    cube14.material = cubeMaterial1;
    
    BABYLON.SceneLoader.ImportMesh("", "/", "toilet.glb", scene, function (meshes, particleSystems, skeletons, animationGroups) {
                
                // Set the position of the first mesh (assuming the entire model is part of this mesh)
                if (meshes.length > 0) {
                    meshes[0].position = new BABYLON.Vector3(-20.5, -10, -20);
                    meshes[0].rotation = new BABYLON.Vector3(0,0,0);
                    meshes[0].scaling = new BABYLON.Vector3(0.037,0.037,0.037);
                    meshes[0].checkCollisions = true;// Set position to (-21, -8, 21)
                }
                
                meshes.forEach(function (mesh) {
                  mesh.checkCollisions = true;
                });
                

            });
            
          BABYLON.SceneLoader.ImportMesh("", "/", "shrekt.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {
                var hero = newMeshes[0];!
               animationGroups[0].stop();
               animationGroups[1].play;
              hero.position = new BABYLON.Vector3(-20, -10, -6.5);
              //hero.checkCollisions = true;
                
            });
            
            BABYLON.SceneLoader.ImportMesh("", "/", "desk.glb", scene, function (meshes) {    
        // Set the position of the imported model
        meshes.forEach(function (mesh) {
            mesh.position = new BABYLON.Vector3(-20, -9.5,-7.5);
            mesh.scaling = new BABYLON.Vector3(4,4,4);
            mesh.checkCollisions = true ;
        });
    });
        
        BABYLON.SceneLoader.ImportMesh("", "/", "fan.glb", scene, function (newMeshes, particleSystems, skeletons, animationGroups) {

               // var hero = newMeshes[0];!
               animationGroups[0].play;
              newMeshes[0].position = new BABYLON.Vector3(-18, -6, -9);
              newMeshes[0].scaling = new BABYLON.Vector3(2,2,2);
              newMeshes[0].checkCollisions = true;
                
            });
        
    
    //Set gravity for the scene (G force like, on Y-axis)
    scene.gravity = new BABYLON.Vector3(0, -9.81 / 60, 0);

    // Enable Collisions
    scene.collisionsEnabled = true;

    //Then apply collisions and gravity to the active camera
    camera.checkCollisions = true;
    camera.applyGravity = true;

    //Set the ellipsoid around the camera (e.g. your player's size)
    camera.ellipsoid = new BABYLON.Vector3(1, 1, 1);

    //finally, say which mesh will be collisionable
    ground.checkCollisions = true;
    //box.checkCollisions = true;

    // Add our custom Joystick+Swipe input
    camera.inputs.clear()
    camera.inputs.add(new FreeCameraTouchVirtualJoystickInput())
    camera.attachControl(canvas, true);
    camera.speed = 2
    BABYLON.Engine.CollisionsEpsilon = 0.0001; // acts as a deadzone for joystick
    camera.inertia = 0.8
    
    var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");



            var jumpButton = BABYLON.GUI.Button.CreateSimpleButton("jumpButton", "Jump");
            jumpButton.width = "100px";
            jumpButton.height = "100px";
            jumpButton.color = "grey";          // Border color
            jumpButton.background = "white";    // Background color
            jumpButton.cornerRadius = 100;      // Make the button circular
            jumpButton.thickness = 4;           // Border thicknes
            jumpButton.textBlock.color = "grey";  // Text color
            jumpButton.textBlock.fontFamily = "monospace";  // Monospace font
            jumpButton.textBlock.fontWeight = "bold";
            jumpButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
            jumpButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
            jumpButton.left = "-5%";   // 10px from right
            jumpButton.top = "-20%";    // 10px from bottom

            gui.addControl(jumpButton);
            
            var isJumping = false;
            var jumpHeight = 1.5;
            var jumpSpeed = 0.08;
            var gravity = -6.5;
            var velocityY = 0;

            jumpButton.onPointerDownObservable.add(function() {
                if (!isJumping) {
                    isJumping = true;
                    velocityY = jumpHeight;
                }
            });
            
            scene.onBeforeRenderObservable.add(function() {
                if (isJumping) {
                    camera.position.y += velocityY;
                    velocityY += gravity * jumpSpeed;

                    if (camera.position.y <= -8) { // Reset position when landing
                        camera.position.y = -8;
                        velocityY = 0;
                        isJumping = false;
                    }
                }
            })
;


            // Function for jump

    return scene;
}


class FreeCameraTouchVirtualJoystickInput extends BABYLON.BaseCameraPointersInput {
    SWIPE_SENSIBILITY = 0.5;
    JOYSTICK_COLOR = "LightGray";
    JOYSTICK_TOUCH_AREA_HORIZONTAL_SCREEN_SHARE = 0.5;
    JOYSTICK_CIRCLE_SIZE_VERTICAL_SCREEN_SHARE = 0.1;
    JOYSTICK_PUCK_SIZE_VERTICAL_SCREEN_SHARE = 0.05;
    JOYSTICK_OUTER_CIRCLE_THICKNESS_RATIO = 0.01;
    JOYSTICK_INNER_CIRCLE_THICKNESS_RATIO = 0.04;
    JOYSTICK_PUCK_THICKNESS_RATIO = 0.01;

    camera;
    joystickDelta = BABYLON.Vector2.Zero();
    screenSize;
    ui;
    joystickPointerId;
    joystickButtonDownPos;
    joystickButtonDownPosOffset;
    joystickContainer;
    joystickOuterCirce;
    joystickInnerCircle;
    joystickPuck;
    joystickCircleRadius;
    joystickPuckRadius;

    getClassName = () => this.constructor.name;

    getSimpleName = () => "joystick"

    attachControl(noPreventDefault) {
        super.attachControl(noPreventDefault);
        this.screenSize = FreeCameraTouchVirtualJoystickInput.getScreenSize();
        this.ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        this.prepareImages(this.screenSize.y);
        BABYLON.EngineStore.LastCreatedEngine.onResizeObservable.add(this.resize);
    }

    prepareImages() {
        this.joystickCircleRadius = this.screenSize.y * this.JOYSTICK_CIRCLE_SIZE_VERTICAL_SCREEN_SHARE;
        this.joystickPuckRadius = this.screenSize.y * this.JOYSTICK_PUCK_SIZE_VERTICAL_SCREEN_SHARE;

        this.joystickContainer = new BABYLON.GUI.Container("virtual_joystick");
        let containerSize = this.joystickCircleRadius * 2 + this.joystickPuckRadius * 2 + 1;
        this.joystickContainer.widthInPixels = containerSize;
        this.joystickContainer.heightInPixels = containerSize;
        this.joystickContainer.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
        this.joystickContainer.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;

        this.joystickOuterCirce = this.prepareJoystickCircle(
            this.joystickCircleRadius,
            containerSize * this.JOYSTICK_OUTER_CIRCLE_THICKNESS_RATIO,
        );
        this.joystickInnerCircle = this.prepareJoystickCircle(
            this.joystickPuckRadius,
            containerSize * this.JOYSTICK_INNER_CIRCLE_THICKNESS_RATIO,
        );
        this.joystickPuck = this.prepareJoystickCircle(
            this.joystickPuckRadius,
            containerSize * this.JOYSTICK_PUCK_THICKNESS_RATIO,
        );

        this.joystickContainer.addControl(this.joystickOuterCirce);
        this.joystickContainer.addControl(this.joystickInnerCircle);
        this.joystickContainer.addControl(this.joystickPuck);
        this.joystickContainer.isVisible = false;
        this.ui.addControl(this.joystickContainer);
    }

    prepareJoystickCircle(radius, thickness) {
        let circle = new BABYLON.GUI.Ellipse();
        circle.widthInPixels = radius * 2;
        circle.heightInPixels = radius * 2;
        circle.thickness = thickness;
        circle.color = this.JOYSTICK_COLOR;
        circle.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
        circle.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        return circle;
    }

    detachControl() {
        this.disposeImages();
        this.ui.dispose();
        BABYLON.EngineStore.LastCreatedEngine.onResizeObservable.removeCallback(this.resize);
        super.detachControl();
    }

    disposeImages() {
        this.joystickContainer.dispose()
        this.joystickInnerCircle.dispose();
        this.joystickOuterCirce.dispose();
        this.joystickPuck.dispose();
    }

    resize = () => {
        this.screenSize = FreeCameraTouchVirtualJoystickInput.getScreenSize();
        this.disposeImages();
        this.prepareImages();
    };

    static getScreenSize() {
        let engine = BABYLON.EngineStore.LastCreatedEngine;
        return new BABYLON.Vector2(engine.getRenderWidth(), engine.getRenderHeight());
    }

    checkInputs() {
        let joystickMoveVector = new BABYLON.Vector3(this.joystickDelta.x, 0, -this.joystickDelta.y);
        joystickMoveVector.scaleInPlace(BABYLON.EngineStore.LastCreatedEngine.getDeltaTime() / 1000);
        this.camera.cameraDirection.addInPlace(
            BABYLON.Vector3.TransformCoordinates(joystickMoveVector, BABYLON.Matrix.RotationY(this.camera.rotation.y)),
        );
    }

    onTouch(point, offsetX, offsetY) {
        if (point.pointerId === this.joystickPointerId) {
            // point refer to global inner window canvas, we need to convert it to local render canvas
            this.onTouchJoystick(
                new BABYLON.Vector2(point.x, point.y).subtractInPlace(this.joystickButtonDownPosOffset),
            );
        } else {
            this.onTouchSwipe(new BABYLON.Vector2(offsetX, offsetY));
        }
    }

    onTouchJoystick(touchPoint) {
        const joystickVector = touchPoint.subtract(this.joystickButtonDownPos);
        if (joystickVector.length() > this.joystickCircleRadius)
            joystickVector.scaleInPlace(this.joystickCircleRadius / joystickVector.length());
        this.joystickPuck.left = joystickVector.x;
        this.joystickPuck.top = joystickVector.y;

        this.joystickDelta = joystickVector.scaleInPlace(this.camera.speed / this.joystickCircleRadius);
    }

    onTouchSwipe(touchOffset) {
        let directionAdjust = 1;
        if (this.camera.getScene().useRightHandedSystem) directionAdjust *= -1;
        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0)
            directionAdjust *= -1;

        this.camera.cameraRotation.y +=
            ((directionAdjust * touchOffset.x) / this.screenSize.x) * this.SWIPE_SENSIBILITY;
        this.camera.cameraRotation.x += (touchOffset.y / this.screenSize.x) * this.SWIPE_SENSIBILITY;
    }

    onButtonDown(evt) {
        if (evt.offsetX < this.screenSize.x * this.JOYSTICK_TOUCH_AREA_HORIZONTAL_SCREEN_SHARE)
            this.onButtonDownJoystick(evt);
    }

    onButtonDownJoystick(evt) {
        let point = new BABYLON.Vector2(evt.offsetX, evt.offsetY);
        this.joystickPointerId = evt.pointerId;
        this.joystickButtonDownPos = point;
        this.joystickButtonDownPosOffset = new BABYLON.Vector2(evt.clientX - point.x, evt.clientY - point.y);
        this.joystickContainer.left = point.x - this.joystickContainer.widthInPixels / 2;
        this.joystickContainer.top = point.y - this.joystickContainer.heightInPixels / 2;
        this.joystickContainer.isVisible = true;
    }

    onButtonUp(evt) {
        if (evt.pointerId === this.joystickPointerId) this.onButtonUpJoystick();
    }

    onButtonUpJoystick() {
        this.joystickPointerId = null;
        this.joystickDelta.scaleInPlace(0);
        this.joystickContainer.isVisible = false;
    }
}

                window.initFunction = async function() {
                    
                    
                    
                    var asyncEngineCreation = async function() {
                        try {
                        return createDefaultEngine();
                        } catch(e) {
                        console.log("the available createEngine function failed. Creating the default engine instead");
                        return createDefaultEngine();
                        }
                    }

                    window.engine = await asyncEngineCreation();
        if (!engine) throw 'engine should not be null.';
        startRenderLoop(engine, canvas);
        window.scene = createScene();};
        initFunction().then(() => {sceneToRender = scene                    
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
    <script src="/new.js"></script>
</body>
</html>
